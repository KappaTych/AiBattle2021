<!DOCTYPE html>
<html>

<head>
    <title>Ai Battle</title>
    <link href="styles/style.css" rel="stylesheet" type="text/css">
    <script src="scripts/ResourceLoader.js"></script>
    <script src="scripts/GameObject.js"></script>
    <script src="scripts/MovableObject.js"></script>
    <script src="scripts/StaticObject.js"></script>
    <script src="scripts/Scene.js"></script>
    <script src="scripts/ReplayRenderer.js"></script>
    <script src="scripts/SafeEval.js"></script>
    <script src="scripts/WorkerWaraper.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.13/ace.js"></script>
</head>

<body>
    <div class="wrapper">
        <div class="buttonWrapper">
            <button class="tab-button active buttonMenu" style="border-top-left-radius: 10px;" data-id="controllerEditorTab">Controller editor</button>
            <button class="tab-button buttonMenu" data-id="mapEditorTab">Map editor</button>
            <button class="tab-button buttonMenu" data-id="gameTab">Game</button>
            <button class="tab-button buttonMenu" style="border-top-right-radius: 10px;" data-id="replayTab" id="replayTabButton">Replay</button>
        </div>
        <div class="contentWrapper">
            <div class="content active" id="controllerEditorTab">
                <table border="2" cellpadding="0" cellspacing="0" margin="auto" align="center" class="fixed">
                    <tr>
                        <td width="70%" height="100%">
                            <div id="editor1_wrapper" class="app_editor_wrapper">
                                <div id="controllerEditorText" class="app_editor"></div>
                                <div class="editorSaveLoad">
                                    <button onclick="PostCodeToCats().then((data) => {alert(data.message);UpdateAllAttemptsListsAndUls();});">Post code to CATS</button>
                                    <button onclick="InitControllerEditorForNewText()">New</button>
                                    <button onclick="SaveController()">SaveAs</button>
                                    <button onclick="LoadAndSetController()">Load</button>
                                    <input id="controllerFileName">
                                </div>
                            </div>
                        </td>
                        <td width="30%" height="100%" vertical-align="top">
                            <div class="ui scroll">
                                <div name="controllerLoader">
                                    <label>Loaded controllers</label>
                                    <ul name="controllerUl" id="controllerUl"></ul>
                                    <input type="file" name="controllerFile" id="controllerFile">
                                    <button onclick="AddController()">Load controller</button>
                                    <button onclick="ClearControllers()">Clear controllers</button>
                                </div>
                                <div style="padding-top: 20px;">
                                    <label>Attempts</label>
                                    <button style="padding: 5px 5px;" onclick="UpdateAllAttemptsListsAndUls()">Update attempts</button>
                                    <br>
                                    <ul id="attemptsUl"></ul>
                                </div>
                            </div>
                        </td>
                    </tr>
                </table>
            </div>
            <div class="content" id="mapEditorTab">
                <table border="2" cellpadding="0" cellspacing="0" margin="auto" align="center" class="fixed">
                    <tr>
                        <td width="70%" height="100%">
                            <div id="editor2_wrapper" class="app_editor_wrapper">
                                <div id="mapEditorText" class="app_editor"></div>
                                <div class="editorSaveLoad">
                                    <button onclick="InitMapEditorForNewText()">New</button>
                                    <button onclick="SaveMap()">Save As</button>
                                    <button onclick="LoadAndSetMap()">Load</button>
                                    <input id="mapFileName">
                                </div>
                            </div>
                        </td>
                        <td width="30%" height="100%" vertical-align="top">
                            <div class="ui scroll">
                                <div name="mapLoader">
                                    <label>Loaded maps</label>
                                    <div class="fixedScroll">
                                        <ul name="mapsUl" id="mapsUl"></ul>
                                    </div>
                                    <input type="file" name="mapFile" id="mapFile">
                                    <button onclick="AddMap()">Load map</button>
                                    <button onclick="ClearMaps()">clear maps</button>
                                    <br>
                                    <div style="padding-top: 20px;">
                                        <button id="updateMapPreview" onclick="UpdateMapPreview()">Update map preview</button>
                                        <br>
                                        <div style="padding-top: 5px;" class="fixedScroll">
                                            <canvas id="mapPreview" width="0" height="0"></canvas>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </td>
                    </tr>
                </table>
            </div>
            <div class="content" id="gameTab">
                <table border="2" cellpadding="0" cellspacing="0" margin="auto" align="center" class="fixed">
                    <tr>
                        <td width="70%" height="100%">
                            <div id="gameWindowContainer" class="scroll">
                                <canvas id='game-canvas'></canvas>
                            </div>
                        </td>
                        <td width="30%" height="100%" vertical-align="top">
                            <div class="ui scroll">
                                <div name="selectMap">
                                    <label>Selected map file</label>
                                    <select name="mapList" onchange="SetMap()" id="mapList"></select>
                                    <!-- <button onclick="SetMap()">SetMap</button> -->
                                </div>

                                <div name="mapInfoDiv" id="mapInfoDiv">
                                    <label> Width:</label>
                                    <label id="mapWidth">Nan</label>
                                    <br>
                                    <label> Height:</label>
                                    <label id="mapHeight">Nan</label>
                                    <br>
                                    <label> Bots:</label>
                                    <ul id="botsList"></ul>
                                    <br>
                                    <label> Turns:</label>
                                    <label id="turnsCount"> Nan:</label>
                                    <br>
                                    <button onclick="StartGame()">Start Game</button>
                                </div>

                                <div style="padding-top: 10px;" name="gameTurnsControllerDiv" id="gameTurnsControllerDiv">
                                    <button onclick="NextStep()">Next step</button>
                                    <br>
                                    <button onclick="AutoStep()">Auto step</button>
                                    <button onclick="NextStepWithTimer()">Next step with timer</button>
                                    <input type="range" min="10" max="1000" step="1" id="botTurnTime" oninput="UpdateOutputForInputRange('botTurnTimeOutput',this.value)">
                                    <output id="botTurnTimeOutput">0</output>
                                    <label for="botTurnTime">Bot turn time ms</label>

                                </div>

                                <div name="renderSettingsDiv" id="renderSettingsDiv">
                                    <button onclick="AutoSizeGameRender()">Autosize render</button>
                                    <input type="range" min="20" max="200" step="1" id="tileSize" oninput="UpdateOutputForInputRange('tileSizeOutput',this.value), UpdateGameRender();">
                                    <output id="tileSizeOutput">0</output>
                                    <label for="tileSize">Tile size</label>
                                </div>
                                <div style="padding-top: 10px;">
                                    <label>Replay name</label>
                                    <input id="replayName">
                                    <button onclick="SaveReplay()">Save replay</button>
                                </div>
                            </div>
                        </td>
                    </tr>
                </table>
            </div>
            <div class="content" id="replayTab">
                <table border="2" cellpadding="0" cellspacing="0" margin="auto" align="center" class="fixed">
                    <tr>
                        <td width="70%" height="100%">
                            <div id="replayWindowContainer" class="scroll">
                                <canvas id='replay-canvas'></canvas>
                            </div>
                        </td>
                        <td width="30%" height="100%" vertical-align="top">
                            <div class="ui scroll">
                                <div>
                                    <label>Selected replay file</label>
                                    <select name="replayList" onchange="SetReplay()" id="replayList"></select>
                                    <br>
                                    <input type="file" name="replayFile" id="replayFile">
                                    <button onclick="LoadReplay()">Load replay</button>
                                    <button onclick="ClearReplays()">Clear replays</button>
                                </div>

                                <div>
                                    <button onclick="AutoSizeReplayRender()">Autosize replay render</button>
                                    <input type="range" min="20" max="200" step="1" id="replayTileSize" oninput="UpdateOutputForInputRange('replayTileSizeOutput',this.value); UpdateReplayRender();">
                                    <output id="replayTileSizeOutput">0</output>
                                    <label for="replayTileSize">Tile size</label>
                                </div>

                                <div>
                                    <button onclick="StartReplay()">Start</button>
                                    <button onclick="PrevReplayTurn()">Prev turn</button>
                                    <button onclick="AutoPlayReplay()">Auto play</button>
                                    <button onclick="NextReplayTurn()">Next turn</button>
                                    <input type="range" min="5" max="100" step="1" id="replayTurnTime" oninput="UpdateOutputForInputRange('replayTurnTimeOutput',this.value)">
                                    <output id="replayTurnTimeOutput">0</output>
                                    <label for="replayTurnTime">Frame time</label>
                                </div>
                                <div style="padding-top: 10px;">
                                    <label>Turn:</label>
                                    <label id="currentTurn">0</label>
                                    <ul id="replayScores"></ul>
                                </div>
                            </div>
                        </td>
                    </tr>
                </table>
            </div>
        </div>
    </div>

    <script>
        const newMapDefText = `{
    "width": 3,
    "height": 3,
    "map": [
        ["*", "*", "*"],
        ["*", ".", "#"],
        ["#", "#", "#"]
    ],
    "startSnowMap": 1,
    "snowIncreasePeriod": 1,
    "snowIncreaseValue": 10,
    "lastSnowIncreaseStep": 10,
    "spawns": [{
            "x": 1,
            "y": 1
        }
    ],
    "bases": [{
            "topLeft": {
                "x": 1,
                "y": 1
            },
            "bottomRight": {
                "x": 1,
                "y": 1
            }
        }
    ],
    "turns": 1
}`;
        const newControllerDefText = `function GetController() {
    return {
        Init: function(mapInfo) {
            this.mapInfo = mapInfo;
        },
        //0 - up, 1 - right, 2 - bottom, 3 - left, 4 - idle 
        GetDirection: function(levelInfo) {
            let dir = 4;
            return dir;
        },
    };
}

GetController();`;

        function InitControllerEditorForNewText() {
            const names = GetControllersNames();
            let index = 0
            while (names.indexOf("newController" + index + ".js") >= 0)
                index++;
            const name = "newController" + index + ".js"
            AddControllerToPool(newControllerDefText, name);
            UpdateAllControllerListsAndUls();
            SetControllerToEditor(name);
        }

        function InitMapEditorForNewText() {
            const names = GetMapsNames();
            let index = 0
            while (names.indexOf("newMap" + index + ".json") >= 0)
                index++;
            const name = "newMap" + index + ".json";
            AddMapToPool(newMapDefText, name);
            UpdateAllMapListsAndUls();
            SetMapToEditor(name);
        }

        function LoadReplay() {
            AddNewObjectToStorage("replayFile", replaysPoolName, UpdateAllReplayListsAndUls, () => true);
        }

        function StartReplay() {
            StopReplayAutoStep();
            SetReplay();
        }

        function PrevReplayTurn() {
            StopReplayAutoStep();
            replayRenderer.PrevTurn(UpdateReplayRender, document.getElementById("replayTurnTime").value);
        }

        function AutoPlayReplay() {
            const replayTurnTime = document.getElementById("replayTurnTime").value;
            if (startedReplayAutoStep) {
                clearInterval(replayTimerId);
            } else {
                replayTimerId = setInterval(function() {
                        if (replayRenderer.turn + 1 < replayRenderer.replay.turns.length) {
                            replayRenderer.NextTurn(UpdateReplayRender, replayTurnTime);
                        } else {
                            StopReplayAutoStep();
                        }
                    },
                    replayTurnTime * (animCount + 1) + 10);
            }
            startedReplayAutoStep = !startedReplayAutoStep;
        }

        function StopReplayAutoStep() {
            if (startedReplayAutoStep) {
                clearInterval(replayTimerId);
                startedReplayAutoStep = false;
            }
        }

        function NextReplayTurn() {
            StopReplayAutoStep();
            replayRenderer.NextTurn(UpdateReplayRender, document.getElementById("replayTurnTime").value);
        }

        function UpdateOutputForInputRange(name, value) {
            document.getElementById(name).value = value;
        }

        function UpdateMapPreview() {
            try {
                mapEditorScene = new Scene(MapInfo.LoadMapFromJson(mapEditor.getValue()), []);
                mapEditorScene.Render(document.getElementById("mapPreview"), 30);
            } catch (error) {
                alert(error);
                return;
            }
        }

        function InitTabs() {
            const tabs = document.querySelector(".wrapper");
            const tabButton = document.querySelectorAll(".tab-button");
            const contents = document.querySelectorAll(".content");

            tabs.onclick = function(e) {
                const id = e.target.dataset.id;
                if (id) {
                    tabButton.forEach(btn => {
                        btn.classList.remove("active");
                    });
                    e.target.classList.add("active");

                    contents.forEach(content => {
                        content.classList.remove("active");
                    });
                    const element = document.getElementById(id);
                    element.classList.add("active");

                    StopGameAutoStep();
                    StopReplayAutoStep();
                }
            }
        }

        function IsNameValid(name) {
            return !(name === null || name === undefined || name.length == 0);
        }

        function SetMapToEditor(name) {
            if (IsNameValid(document.getElementById("mapFileName").value))
                SaveMap();
            if (!MapExistInPool(name)) {
                alert("Map not found");
                return;
            }
            mapEditor.setValue(GetObjectFromStorageByName(name));
            document.getElementById("mapFileName").value = name;
        }

        function SetControllerToEditor(name) {
            if (IsNameValid(document.getElementById("controllerFileName").value))
                SaveController();
            if (!ControllerExistInPool(name)) {
                alert("Map not found");
                return;
            }
            controllerEditor.setValue(GetObjectFromStorageByName(name));
            document.getElementById("controllerFileName").value = name;
        }

        function DeleteController(name) {
            RemoveControllerFromPool(name);
            UpdateAllControllerListsAndUls();
        }

        function DeleteMap(name) {
            RemoveMapFromPool(name);
            UpdateAllMapListsAndUls();
        }

        function SaveController() {
            let name = document.getElementById("controllerFileName").value;
            if (!IsNameValid(name)) {
                alert("bad name");
                return;
            }
            AddControllerToPool(controllerEditor.getValue(), name);
            UpdateAllControllerListsAndUls();
        }

        function LoadAndSetController() {
            let name = document.getElementById("controllerFileName").value;
            if (!IsNameValid(name)) {
                alert("bad name");
                return;
            }
            SetControllerToEditor(name);
        }

        function SaveMap() {
            let name = document.getElementById("mapFileName").value;
            if (!IsNameValid(name)) {
                alert("bad name");
                return;
            }

            try {
                if (!MapInfo.IsJsonValid(mapEditor.getValue()).valid) {
                    return;
                }
            } catch (error) {
                alert(error);
                return;
            }

            AddMapToPool(mapEditor.getValue(), name);
            UpdateAllMapListsAndUls();
        }

        function LoadAndSetMap() {
            let name = document.getElementById("mapFileName").value;
            if (!IsNameValid(name)) {
                alert("bad name");
                return;
            }
            SetMapToEditor(name);
        }

        function UpdateSelect(select, names) {
            if (names == null && names == undefined)
                return;
            while (select.firstChild) {
                select.removeChild(select.firstChild);
            }
            for (let i = 0; i < names.length; ++i) {
                let option = document.createElement("option");
                option.text = names[i];
                select.add(option);
            }
        }

        function UpdateEditorUl(ul, names, onDelete, onEdit) {
            if (names == null && names == undefined)
                return;

            while (ul.firstChild) {
                ul.removeChild(ul.firstChild);
            }

            for (let i = 0; i < names.length; ++i) {
                let li = document.createElement("li");

                let deleteButton = document.createElement("button");
                deleteButton.classList.add("delete_button");
                deleteButton.innerHTML = "&nbsp;";
                deleteButton.title = "Delete";
                deleteButton.onclick = function() {
                    onDelete(names[i]);
                }

                let editButton = document.createElement("button");
                editButton.classList.add("edit_button");
                editButton.innerHTML = "&nbsp;";
                editButton.title = "Edit";
                editButton.onclick = function() {
                    onEdit(names[i]);
                }

                let text = document.createElement("span");
                text.classList = "text";
                text.innerHTML = names[i];

                li.appendChild(deleteButton);
                li.appendChild(editButton);
                li.appendChild(text);
                ul.appendChild(li);
            }
        }

        function AddNewObjectToStorage(inputName, pullName, updateFunction, checkDataFunction) {
            let inputFile = document.getElementById(inputName);
            if (inputFile.files.length > 0) {
                for (let i = 0; i < inputFile.files.length; ++i) {
                    let reader = new FileReader();
                    reader.readAsText(inputFile.files[i]);
                    reader.onload = function() {
                        if (checkDataFunction !== null && checkDataFunction !== undefined) {
                            try {
                                if (checkDataFunction(reader.result)) {
                                    AddToPool(reader.result, inputFile.files[i].name, pullName);
                                    updateFunction();
                                } else {
                                    alert("Wrong format");
                                    return;
                                }
                            } catch (error) {
                                alert(error);
                                return;
                            }

                        } else {
                            AddToPool(reader.result, inputFile.files[i].name, pullName);
                            updateFunction();
                        }
                    };

                    reader.onerror = function() {
                        console.log(reader.error);
                    };
                }
            }
        }

        function SaveReplay() {
            const inputFile = document.getElementById("replayName");
            if (!IsNameValid(inputFile.value)) {
                alert("Bad file name");
                return;
            }
            if (gameScene === null || gameScene === undefined) {
                alert("Game not started");
                return;
            }

            AddReplay(gameScene.GetLogs(), inputFile.value);

            UpdateAllReplayListsAndUls();
        }

        function AddMap() {
            AddNewObjectToStorage("mapFile", mapsPoolName, UpdateAllMapListsAndUls, function(obj) {
                return MapInfo.IsJsonValid(obj).valid;
            });
        }

        function ClearReplays() {
            ClearReplaysPool();
            UpdateAllReplayListsAndUls();
        }

        function ClearMaps() {
            ClearMapsPool();
            UpdateAllMapListsAndUls();
        }

        function AddController() {
            AddNewObjectToStorage("controllerFile", controllersPoolName, UpdateAllControllerListsAndUls, ValidateControllerText);
        }

        function ClearControllers() {
            ClearControllersPool();
            UpdateAllControllerListsAndUls();
        }

        function GetDataFromBotInfoDiv(infoDiv) {
            let botName = null;
            let type = null;
            let score = null;

            for (let i = 0; i < infoDiv.children.length; ++i) {
                if (infoDiv.children[i].name == "name")
                    botName = infoDiv.children[i];
                if (infoDiv.children[i].name == "type")
                    type = infoDiv.children[i];
                if (infoDiv.children[i].name == "score")
                    score = infoDiv.children[i];
            }

            return {
                botName: botName,
                type: type,
                score: score
            };
        }

        function StartGame() {
            StopGameAutoStep();

            let select = document.getElementById("mapList");
            if (select.selectedIndex == -1)
                return null;
            let mapText = GetObjectFromStorageByName(select.options[select.selectedIndex].text);
            gameScene.mapInfo = MapInfo.LoadMapFromJson(mapText);

            bots = []
            let botsList = document.getElementById("botsList");
            for (let i = 0; i < botsList.children.length; ++i) {
                let infoDiv = botsList.children[i].children[0];
                let data = GetDataFromBotInfoDiv(infoDiv);

                if (data.type.selectedIndex == -1)
                    throw "select for ai has index=-1";
                if (data.type.options[data.type.selectedIndex].text == "none")
                    continue;

                let controllerScript = GetObjectFromStorageByName(data.type.options[data.type.selectedIndex].text);
                let controller = LoadControllerFromString(controllerScript);
                bots.push(new Bot(0, 0, 0, controller, data.botName.value, colors[i]));
            }

            gameScene = new Scene(gameScene.mapInfo, bots, true, 100,
                //Hack when bots length = 0, call Update after scene assign 
                function() {
                    setTimeout(UpdateGameRender, 0);
                }, true, true);
        }

        function UpdateGameRender() {
            if (gameScene === null || gameScene === undefined) {
                console.warn("The games is not loaded.");
                return;
            }

            let x = document.getElementById("tileSize").value;
            let canvas = document.getElementById("game-canvas");
            gameScene.Render(canvas, x);
            document.getElementById('turnsCount').innerHTML = gameScene.mapInfo.turns;
            let scores = gameScene.CalcScores()
            for (let i = 0; i < scores.length; ++i) {
                GetDataFromBotInfoDiv(document.getElementById(scores[i].botName + "InfoDiv")).score.innerHTML = scores[i].value + ":" + scores[i].state;
            }
        }

        function UpdateReplayRender() {
            if (replayRenderer === null || replayRenderer === undefined) {
                console.warn("The replay is not loaded.");
                return;
            }

            let x = document.getElementById("replayTileSize").value;
            let canvas = document.getElementById("replay-canvas");
            replayRenderer.Render(canvas, x);
            document.getElementById('currentTurn').innerHTML = replayRenderer.turn;
            let scores = replayRenderer.CalcScores();

            let ul = document.getElementById("replayScores");
            while (ul.firstChild) {
                ul.removeChild(ul.firstChild);
            }

            for (let i = 0; i < scores.length; ++i) {
                const li = document.createElement("li");
                const colorDiv = document.createElement("div");
                colorDiv.setAttribute("style", "display:inline-block;width:20px; height:20px;");
                colorDiv.style.backgroundColor = scores[i].botColor;
                const label = document.createElement("label");
                label.innerHTML = scores[i].botName + ":" + scores[i].value;
                li.appendChild(colorDiv);
                li.appendChild(label);
                ul.appendChild(li);
            }
        }

        function StopGameAutoStep() {
            if (startedGameAutoStep) {
                startedGameAutoStep = false;
            }
        }

        function AutoStep() {
            startedGameAutoStep = !startedGameAutoStep;
            if (startedGameAutoStep)
                ScheduleGameStep(true);
        }

        function NextStep() {
            StopGameAutoStep();
            let scores = gameScene.NextStep();
            UpdateGameRender();
        }

        function NextStepWithTimer(isAuto = false) {
            gameScene.NextStepWithTimer(document.getElementById("botTurnTime").value, () => {
                UpdateGameRenderWithStep(isAuto);
            });
        }

        function UpdateGameRenderWithStep(isAuto = false) {
            UpdateGameRender();
            if (isAuto && startedGameAutoStep)
                ScheduleGameStep(isAuto);
        }

        function ScheduleGameStep(isAuto) {
            setTimeout(function() {
                if (gameScene.mapInfo.turns > 0) {
                    NextStepWithTimer(isAuto);
                } else {
                    StopGameAutoStep();
                }
            }, 0);
        }

        function ResetMapUI() {
            let ul = document.getElementById("botsList");
            while (ul.firstChild) {
                ul.removeChild(ul.firstChild);
            }

            document.getElementById('mapWidth').innerHTML = 0;
            document.getElementById('mapHeight').innerHTML = 0;
            document.getElementById('turnsCount').innerHTML = 0;
            let canvas = document.getElementById("game-canvas");
            const context = canvas.getContext('2d');
            context.clearRect(0, 0, canvas.width, canvas.height);
        }

        function AutoSizeGameRender() {
            let tileSize = document.getElementById("tileSize");
            let size = GetGameCanvasSuitableSize();
            size = Math.min(Math.max(size, tileSize.min), tileSize.max);
            tileSize.value = size;
            tileSize.oninput();
            UpdateOutputForInputRange("tileSizeOutput", size)
            UpdateGameRender();
        }

        function AutoSizeReplayRender() {
            let tileSize = document.getElementById("replayTileSize");
            let size = GetReplayCanvasSuitableSize();
            size = Math.min(Math.max(size, tileSize.min), tileSize.max);
            tileSize.value = size;
            tileSize.oninput();
            UpdateOutputForInputRange("replayTileSizeOutput", size)
            UpdateReplayRender();
        }

        function SetReplay() {
            StopReplayAutoStep();
            let select = document.getElementById("replayList");
            if (select.selectedIndex == -1)
                return null;

            let replayText = GetObjectFromStorageByName(select.options[select.selectedIndex].text);
            replayRenderer = new ReplayRenderer(JSON.parse(replayText), animCount, UpdateReplayRender);
            AutoSizeReplayRender();
        }

        function SetMap() {
            StopGameAutoStep()

            let select = document.getElementById("mapList");
            let canvas = document.getElementById("game-canvas");

            ResetMapUI();

            if (select.selectedIndex == -1)
                return null;

            let mapText = GetObjectFromStorageByName(select.options[select.selectedIndex].text);
            gameScene = new Scene(MapInfo.LoadMapFromJson(mapText), []);

            document.getElementById('mapWidth').innerHTML = gameScene.mapInfo.width;
            document.getElementById('mapHeight').innerHTML = gameScene.mapInfo.height;

            let botsList = document.getElementById("botsList");
            for (let i = 0; i < gameScene.mapInfo.spawns.length; ++i) {
                let botName = "bot#" + i;

                let botInfoDiv = document.createElement("div");
                botInfoDiv.id = botName + "InfoDiv";

                const colorDiv = document.createElement("div");
                colorDiv.setAttribute("style", "display:inline-block;width:20px; height:20px;");
                colorDiv.style.backgroundColor = colors[i];

                let selectList = document.createElement("select");
                selectList.name = "type";
                UpdateSelect(selectList, [...["none"], ...GetControllersNames()]);

                let input = document.createElement("input");
                input.value = botName;
                input.name = "name";
                input.size = 12;
                input.onchange = function() {
                    if (document.getElementById(input.value + "InfoDiv") === null || document.getElementById(input.value + "InfoDiv" === undefined)) {
                        gameScene.RenameBot(botInfoDiv.id.replace("InfoDiv", ""), input.value);
                        botInfoDiv.id = input.value + "InfoDiv";
                        UpdateGameRender();
                    } else {
                        input.value = botInfoDiv.id.replace("InfoDiv", "");
                        alert("bot name " + input.value + " already exist");
                    }
                }

                let scoreLabel = document.createElement("label");
                scoreLabel.innerHTML = 0;
                scoreLabel.name = "score";

                botInfoDiv.appendChild(colorDiv);
                botInfoDiv.appendChild(input);
                botInfoDiv.appendChild(selectList);
                botInfoDiv.appendChild(scoreLabel)

                let li = document.createElement("li");
                li.appendChild(botInfoDiv);

                botsList.appendChild(li);
            }

            document.getElementById('turnsCount').innerHTML = gameScene.mapInfo.turns;

            AutoSizeGameRender();
        }

        function InitAceEditor(name, modePath) {
            let editor = ace.edit(name);
            editor.setTheme("ace/theme/clouds");
            editor.session.setMode({
                path: modePath,
                inline: true
            });
            return editor;
        }

        function UpdateAllMapListsAndUls() {
            UpdateSelect(document.getElementById("mapList"), GetMapsNames());
            UpdateEditorUl(document.getElementById("mapsUl"), GetMapsNames(), DeleteMap, SetMapToEditor);
            SetMap();
        }

        function UpdateAllControllerListsAndUls() {
            UpdateEditorUl(document.getElementById("controllerUl"), GetControllersNames(), DeleteController, SetControllerToEditor);
            SetMap();
        }

        function UpdateAllReplayListsAndUls() {
            UpdateSelect(document.getElementById("replayList"), GetReplaysNames());
            SetReplay();
        }

        function UpdateAllAttemptsListsAndUls() {
            LoadAttempts().then((attempts) => {
                const ul = document.getElementById("attemptsUl");
                while (ul.firstChild) {
                    ul.removeChild(ul.firstChild);
                }

                if (attempts === null || attempts === undefined)
                    return;

                for (let i = 0; i < attempts.length; ++i) {
                    let li = document.createElement("li");

                    let editButton = document.createElement("button");
                    editButton.classList.add("edit_button");
                    editButton.innerHTML = "&nbsp;";
                    editButton.title = "Edit";
                    editButton.onclick = async function() {
                        const query = QueryParams();
                        if (!(query.sid && query.cid)) {
                            console.warn("Bad cats path");
                            return;
                        }
                        const url = "https://imcs.dvfu.ru/cats/?f=download_source" + ";sid=" + query.sid + ";cid=" + query.cid + ";json=1" +
                            ";rid=" + attempts[i].id + ";";
                        let response = await fetch(url, {
                            method: 'GET'
                        });
                        response.text().then((text) => {
                            SaveController();
                            controllerEditor.setValue(text);
                            document.getElementById("controllerFileName").value = attempts[i].id;
                        })
                    }

                    const query = QueryParams();
                    if (!(query.sid && query.cid)) {
                        console.warn("Bad cats path");
                        return;
                    }

                    let text = document.createElement("span");
                    text.classList = "text";
                    text.innerHTML = attempts[i].id + ":" + attempts[i].state_text;

                    li.appendChild(editButton);
                    li.appendChild(text);
                    ul.appendChild(li);
                }
            });
        }

        async function LoadSubAttempts(cid, sid, parent_id) {
            const url = "https://imcs.dvfu.ru/cats/?f=console" + ";sid=" + sid + ";cid=" + cid + ";search=contest_id=this,parent_id=" + parent_id + ";json=1";
            let response = await fetch(url, {
                method: 'GET'
            });
            return await response.json();
        }

        async function GetInfoFromSubmite(cid, sid, rid) {
            const url = "https://imcs.dvfu.ru/cats/?f=run_details" + ";sid=" + sid + ";cid=" + cid + ";rid=" + rid + ";json=1"
            let response = await fetch(url, {
                method: 'GET'
            });
            return await response.json();
        }

        async function LoadReplayFromCats(sid, cid, rid, test_rank) {
            const url = "https://imcs.dvfu.ru/cats/?f=view_test_details" + ";sid=" + sid + ";cid=" + cid + ";json=1" + ";test_rank=" + test_rank +
                ";rid=" + rid + ";";
            let response = await fetch(url, {
                method: 'GET'
            });

            let subAttempts = await LoadSubAttempts(cid, sid, rid);
            const names = [];
            for (let i = 0; i < subAttempts.length; ++i) {
                const a = await GetInfoFromSubmite(cid, sid, subAttempts[i].id);
                names.push(a.sources[0].orig_team);
            }

            response.json().then((ans) => {
                const name = rid + ":" + test_rank;
                let rep = ans.output.data ? JSON.parse(ans.output.data) : JSON.parse(ans.input.data);

                for (let i = 0; i < names.length; ++i)
                    rep.startBotsInfo[i].name = names[i].split(" ")[0];
                AddReplay(JSON.stringify(rep), name);
                UpdateAllReplayListsAndUls();
                const list = document.getElementById("replayList");
                for (var i = 0; i < list.options.length; ++i) {
                    if (list.options[i].innerHTML === name) {
                        list.selectedIndex = i;
                        break;
                    }
                }
                document.querySelector(".wrapper").onclick({
                    target: document.getElementById("replayTabButton")
                });
                list.onchange();
            });
        }

        function InitControllerEditor() {
            let controllerFileName = document.getElementById("controllerFileName");
            controllerFileName.value = "";
            controllerEditor = InitAceEditor("controllerEditorText", "ace/mode/javascript");
            let controllersNames = GetControllersNames();
            if (controllersNames.length > 0) {
                controllerFileName.value = controllersNames[0];
                controllerEditor.setValue(GetObjectFromStorageByName(controllerFileName.value));
            }
        }

        function InitMapEditor() {
            let mapFileName = document.getElementById("mapFileName");
            mapFileName.value = "";
            mapEditor = InitAceEditor("mapEditorText", "ace/mode/json");
            let mapsNames = GetMapsNames();
            if (mapsNames.length > 0) {
                mapFileName.value = mapsNames[0];
                mapEditor.setValue((GetObjectFromStorageByName(mapFileName.value)));
            }
        }

        function InitEditors() {
            InitControllerEditor();
            InitMapEditor();
        }

        function GetGameCanvasSuitableSize() {
            if (gameScene.mapInfo === null || gameScene.mapInfo === undefined)
                return;
            let gameWindowContainer = document.getElementById("gameWindowContainer");
            let width = Math.floor(gameWindowContainer.offsetWidth / gameScene.mapInfo.width);
            let height = Math.floor(gameWindowContainer.offsetHeight / gameScene.mapInfo.height);

            return Math.min(width, height);
        }

        function GetReplayCanvasSuitableSize() {
            let mapWidth = replayRenderer.replay.mapStartState.width;
            let mapHeight = replayRenderer.replay.mapStartState.height;
            let gameWindowContainer = document.getElementById("replayWindowContainer");
            let width = Math.floor(gameWindowContainer.offsetWidth / mapWidth);
            let height = Math.floor(gameWindowContainer.offsetHeight / mapHeight);
            return Math.min(width, height);
        }


        function UpdateRangeInputs() {
            document.getElementById("botTurnTime").oninput();
            document.getElementById("tileSize").oninput();
            document.getElementById("replayTileSize").oninput();
            document.getElementById("replayTurnTime").oninput();
        }

        function GetMapsFromGit() {
            const baseUrl = "https://gershuk.github.io/AiBattle/maps/"
            fetch(baseUrl + "baseMapList.json")
                .then((response) => {
                    return response.json();
                })
                .then((data) => {
                    for (let i = 0; i < data.length; ++i) {
                        const name = data[i];
                        fetch(baseUrl + name)
                            .then((response) => {
                                return response.text();
                            })
                            .then((data) => {
                                AddMapToPool(data, name);
                                UpdateAllMapListsAndUls();
                            });
                    }
                });
        }

        function GetBotsFromGit() {
            const baseUrl = "https://gershuk.github.io/AiBattle/bots/"
            fetch(baseUrl + "baseBotList.json")
                .then((response) => {
                    return response.json();
                })
                .then((data) => {
                    for (let i = 0; i < data.length; ++i) {
                        const name = data[i];
                        fetch(baseUrl + name)
                            .then((response) => {
                                return response.text();
                            })
                            .then((data) => {
                                AddControllerToPool(data, name);
                                UpdateAllControllerListsAndUls();
                            });
                    }
                });
        }

        function QueryParams() {
            var url = window.location.search;
            var qs = url.substring(url.indexOf('?') + 1).split(';');
            for (var i = 0, result = {}; i < qs.length; i++) {
                qs[i] = qs[i].split('=');
                result[qs[i][0]] = decodeURIComponent(qs[i][1]);
            }
            return result;
        };

        async function PostCodeToCats() {
            const query = QueryParams();
            if (!(query.sid && query.cid)) {
                console.warn("Bad cats path");
                return;
            }

            try {
                if (!ValidateControllerText(controllerEditor.getValue())) {
                    return;
                }
            } catch (er) {
                alert(er);
                return;
            }

            const formData = new FormData();
            formData.append("submitted", "1");
            formData.append("problem_id", "5913375");
            formData.append("de_id", "1067097");
            formData.append("source_text", controllerEditor.getValue());
            formData.append("submit", "1");

            const url = 'https://imcs.dvfu.ru/cats/?f=problems' + ";sid=" + query.sid + ";cid=" + query.cid + ';json=1;';
            let response = await fetch(url, {
                method: 'POST',
                body: formData
            });

            return await response.json()
        }

        async function LoadAttempts() {
            const query = QueryParams();
            if (!(query.sid && query.cid)) {
                console.warn("Bad cats path");
                return;
            }

            const url = 'https://imcs.dvfu.ru/cats/?f=console' + ";sid=" + query.sid + ";cid=" + query.cid + ';search=account_id%3Dthis;json=1;';
            let response = await fetch(url, {
                method: 'GET'
            });

            return await response.json()
        }

        let controllerEditor = null;
        let mapEditor = null;

        let gameScene = null;
        let mapEditorScene = null;
        let replayRenderer = null;

        let startedGameAutoStep = false;

        let startedReplayAutoStep = false;
        let replayTimerId = null;

        const animCount = 10;

        const colors = [
            "red",
            "orange",
            "yellow",
            "green",
            "blue",
            "indigo",
            "violet",
            "white",
        ];

        //preload image
        new Tree();
        new Wall();
        new Field();
        new Snowball();
        for (let index in colors) {
            new Bot(0, 0, 0, null, colors[index], colors[index]);
        }

        window.onload = function() {
            if (GetMapsNames().length === 0)
                GetMapsFromGit();

            if (GetControllersNames().length === 0)
                GetBotsFromGit();

            InitTabs();
            InitEditors();
            UpdateAllControllerListsAndUls();
            UpdateAllMapListsAndUls();
            UpdateAllReplayListsAndUls();
            UpdateRangeInputs();
            UpdateAllAttemptsListsAndUls();

            const query = QueryParams();
            if (window.location.href.includes("?f=replay") && query.sid && query.rid && query.cid && query.test_rank) {
                LoadReplayFromCats(query.sid, query.cid, query.rid, query.test_rank);
            }
        }
    </script>
</body>

</html>